<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>FARUK HOLOGRAM</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="module">
    // Daha stabil bir sürüm kullanıyoruz
    import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';

    let scene, camera, renderer, textMesh, particleSystem;

    init();
    animate();

    function init() {
        // 1. SAHNE
        scene = new THREE.Scene();
        // Hafif mavi bir sis
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        // 2. KAMERA
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        // 3. HOLOGRAM YAZISI (Canvas Texture Yöntemi - Garanti Çalışır)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 256;

        // Arka plan şeffaf kalsın diye boyamıyoruz
        
        // Yazı Ayarları (Neon Efektli)
        ctx.font = 'Bold 150px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Parlama efekti (Glow)
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = 20;
        ctx.fillStyle = "white";
        ctx.fillText("FARUK", 512, 128);
        
        // Bir kat daha yazıp parlaklığı artıralım
        ctx.shadowBlur = 40;
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 5;
        ctx.strokeText("FARUK", 512, 128);

        // Texture oluştur
        const texture = new THREE.CanvasTexture(canvas);
        
        // Materyal (Işık saçan materyal)
        const material = new THREE.MeshBasicMaterial({ 
            map: texture, 
            transparent: true, 
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending // Parlaklık modu
        });

        // Geometri (Yazıyı taşıyan levha)
        const geometry = new THREE.PlaneGeometry(60, 15);
        textMesh = new THREE.Mesh(geometry, material);
        scene.add(textMesh);

        // 4. ORTAM PARÇACIKLARI (Yıldızlar/Tozlar)
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 2000;
        const posArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i++) {
            // Rastgele dağıt
            posArray[i] = (Math.random() - 0.5) * 200; 
        }

        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.5,
            color: 0x00ffff, // Mavi neon rengi
            transparent: true,
            opacity: 0.8
        });

        particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);

        // 5. RENDERER
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Pencere boyutu değişirse
        window.addEventListener('resize', onWindowResize);
        
        // Fare hareketi
        document.addEventListener('mousemove', onMouseMove);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let mouseX = 0;
    let mouseY = 0;

    function onMouseMove(event) {
        // Fare pozisyonunu -1 ile 1 arasına getir
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function animate() {
        requestAnimationFrame(animate);

        // Yazı hareketi (Hologram gibi süzülsün)
        if (textMesh) {
            // Fareye göre dönme
            textMesh.rotation.x = mouseY * 0.2;
            textMesh.rotation.y = mouseX * 0.2;
            
            // Kendi kendine hafif salınım
            textMesh.position.y = Math.sin(Date.now() * 0.002) * 2;
        }

        // Parçacıklar sürekli dönsün (Uzay hissi)
        if (particleSystem) {
            particleSystem.rotation.y += 0.001;
            particleSystem.rotation.x += 0.0005;
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
